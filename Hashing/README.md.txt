Hashing:

Generally speaking, hashing is about to maintain the collection, where our data is kept, in well-organized manner so one can insert and retrieve the data easily wihtout searching through the whole bunch of slots available in our hash table (or collection).

It is used for fast lookup. For instance, in libraries all the books are kept into the specified slots based on their titles or categories. We just go to that slot and pick our requirements without any kinda delay.

Programmatically speaking, hashing determines the hash code for specific object and then it maps a link to the hash table for keeping our data to specific position (key) generated by the hash function, this whole process is known as a hashing.

We can harness the power of hash for security considerations. For instance, lets say I want to visit my bank account digitally but I have to go through the login form first and here we are prompted the username and password. Our password and username are used as a hash code that points our account in the collection of the databases. The valid credentials grants the access to my account. Otherwise it will trigger an alert as per the setup.

There are sometimes the problem encounter when dealing with hashing that is the hash collision. Hash collision means when your position or key is already occupied by some other value or object. To manage such collisions we have two kind of techniques:
- Open Hashing
- Closed Hashing


Open Hashing:
	It is a most commonly used technique. Whenever we encounter with the collision, the object remain at the same slot/key but lined up together by creating a single linked list. There are few disadvantages:
- Wastage of space
- Time taken process when it comes to the searching.

Closed Hashing:
	It stores all of its object within the collection (array) without creating a linked list at the collide position.
There are further 3 techniques to resolve the collision in closed hashing.
- Linear Probing (Hashing)
- Quadratic Probing
- Double Hashing

Linear Probing:
	It is quite simple and easy. Considering an example of chairs in a row, if our position is already occupied by some visitors then we lookup to other chair one by one until we found an empty chair.

Quadratic Probing:
	It is similar to the linear probing but not identical in a way of lookup. It actually uses a spaced-out approach as it generate the hash code at an increasing distance. Unlike linear probing, it reduces the chances of re-clustering. The algorithm it uses:
key = ((hash(n) + x * x) % T) where x is number of elements present in a hash table of the same value 

For instance if 1 is not present on our hash table then x = 1
key = (1 + 1 * 1) % 10
if we encounter with the same value (1) for the second time
key = (1 + 2 * 2) % 10

Double Hashing:
	It contains a backup plan/function named as second hash. Double Hashing first generate the hash code by the first hash function. If that slot is occupied then second hash function generate its own hash code. It sums up the code generated by both hash functions and then we have a random position to store the object. It repeats its process until an empty space is found. This process gives us a randomized position.

Algorithm:
key = (first hash(key) + i * secondHash(key)) % size 